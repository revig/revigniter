{"version":3,"names":["walkDOM","rootEl","callback","node","firstElementChild","nextElementSibling","debounce","func","wait","immediate","timeout","context","this","args","arguments","clearTimeout","setTimeout","apply","asynDirectives","el","DirectiveManager","constructor","directives","extractTypeModifiersAndValue","all","has","type","map","directive","includes","missing","get","find","Array","from","getAttributeNames","filter","name","match","RegExp","modifiers","replace","split","Directive","fullName","eventContext","lcFunc","emitEvent","setEventContext","isEmitEvent","theBool","value","getAttribute","lcFunction","fullVal","search","modelValue","undefined","innerText","handler","parseOutHandlerAndParams","params","durationOr","defaultDuration","durationInMilliSeconds","durationInMilliSecondsString","mod","durationInSecondsString","Number","rawHandler","handlerAndParamString","Function","cardinalDirectionOr","fallback","modelSyncDebounce","time","modelDebounceCallbacks","callbackRegister","push","e","Action","skipWatcher","updateQueue","EventAction","modelAttrVal","modelVal","isCustomEvent","super","payload","toId","btoa","encodeURIComponent","event","JSON","stringify","dispatch","eventName","options","theHandler","CustomEvent","addEventListener","dispatchEvent","MessageBus","listeners","register","call","forEach","Object","keys","HookManager","availableHooks","bus","store","csrf","transmissionEls","mutables","mutableElem","url","asynergyIsInBackground","asynergyIsOffline","hooks","agents","nodesSetToDisabled","nodesSetToReadOnly","mutableIncludesModel","theAgents","key","registerHook","callHook","addAgent","agent","length","getAgentsByID","agentID","tearDownAgents","agentsLength","i","index","removeAgent","emit","agentsListeningForEvent","addAction","addEmitEvent","directiveParams","handlerName","on","paramsA","modelParams","selectValues","isArray","toString","checked","detail","option","indexOf","setAttribute","removeAttribute","tearDown","splice","transmissionElsData","listenerType","modelValueKey","transmissionElIsCheckbox","transmissionElIsRadio","transmissionElIsMutable","mutable","isChecked","tagName","innerHTML","modelData","addDisabledNode","theNode","addReadOnlyNode","clearDisabledReadOnlyNodesArrays","disabled","readOnly","mutabelsData","mutablesData","mutableAttrVal","mutableInnerHTML","id","DeferredModelAction","Deferred","deferredActions","deferredActionsData","payloadDeferred","action","hasOwnProperty","actionData","exec","substr","Connection","URL","updateEl","modelEl","ajax","completed_callback","headers","asynPayload","actionType","modelSyncTimeout","reregisterEvLis","onMessage","message","receiveMessage","handleResponse","responseObj","fetchedResponse","connection","values","asynergyResponse","respItem","mutableVal","updated","updateMutablesByID","updateMutablesByAttrVal","syncModels","location","ASYNergy","reregisterEventListeners","msg","updates","tokenName","token","deferredModelData","fetch","method","Accept","Referer","window","href","body","then","response","ok","text","parse","catch","error","console","warn","mutableID","theID","document","getElementById","nodeName","attrValFragments","attrValPrefix","syncModelID","modelID","timer","model","mutableEl","timeOut","DOM","allModelElementsInside","root","querySelectorAll","getByAttributeAndValue","attribute","querySelector","hasAttribute","hasFocus","activeElement","isInput","toUpperCase","isTextInput","valueFromInput","modelName","mergeCheckboxValueIntoArray","multiple","getSelectValues","arrayValue","concat","item","setInputValueFromModel","modelString","data","toLowerCase","setInputValue","valueFound","val","updateSelect","selected","arrayWrappedValue","HandlerAction","ModelAction","Message","update","storeResponse","Agent","postValue","messageInTransit","tearDownCallbacks","scopedListeners","fireMessage","entries","unshift","sendMessage","doReplayResponse","walk","callbackWhenNewComponentIsEncountered","isSameNode","callAfterModelDebounce","addListenerForTeardown","teardownCallback","nodeInitializer","initialize","reregisterEvl","isAgent","directiveVal","compoundAttrVal","attr","modelAttr","modelElem","attachModelListener","attachDomListener","theAgent","eventType","isLazy","sliderElement","sliderValueElement","valUnit","directiveValues","regex","matches","oninput","hasDebounceModifier","initConnection","condition","target","documentMode","removeEventListener","test","navigator","userAgent","animationName","Event","bubbles","attachListener","selectedSystemKeyModifiers","keyCode","modifier","Boolean","preventAndStop","debouncedHandler","debounceIf","preventDefault","stopPropagation","attrVal","escapedStr","escFullName","str","x","cleanupStackByAgentId","cleanup","shift","ASYNergyStateManager","replaceState","updateState","pushState","state","currentState","stateArray","toStateArray","fullstateObject","assign","history","subject","charAt","slice","decodeURI","replaceAll","storeInSession","asynergy","replayResponses","ASYNergyState","getFromSession","missingState","clearState","Date","getTime","stringifiedValue","tryToStoreInSession","sessionStorage","setItem","code","oldestTimestamp","sort","removeItem","getItem","items","pushItemInProperOrder","signature","targetItem","existingIndex","findIndex","findAgentBySignature","appVersion","version","theURL","hook","stop","start","bodyEl","hidden","initializedPath","agentIdsThatAreWritingToHistoryState","Set","browserHistoryOn","responseItemNum","mutablesItem","add","replaying","effects","SyncBrowserHistory","targetedLoadingElsByAction","genericLoadingEls","currentlyActiveLoadingEls","currentlyActiveUploadLoadingEls","generateSignatureFromHandlerAndParams","modelActions","reduce","fullAction","part","flat","contains","intervalId","interval","setInterval","isConnected","Math","random","bounding","getBoundingClientRect","top","innerHeight","documentElement","clientHeight","left","innerWidth","clientWidth","bottom","right","inViewport","fireActionOnInterval","clearInterval","__asynergy_polling_interval"],"sources":["../src/util/walkDOM.js","../src/util/debounce.js","../src/util/asynDirectives.js","../src/action/index.js","../src/action/event.js","../src/util/dispatch.js","../src/MessageBus.js","../src/HookManager.js","../src/Store.js","../src/DirectiveManager.js","../src/action/deferred-model.js","../src/action/Deferred.js","../src/connection/index.js","../src/dom/dom.js","../src/action/handler.js","../src/action/model.js","../src/Message.js","../src/agent/index.js","../src/init_tasks.js","../src/util/index.js","../src/agent/DisableForms.js","../src/agent/SyncBrowserHistory.js","../src/index.js","../src/agent/LoadingStates.js","../src/agent/Polling.js"],"sourcesContent":["export function walkDOM(rootEl, callback) {\n    if (callback(rootEl) === false) {\n        return;\n    }\n\n    let node = rootEl.firstElementChild;\n\n    while (node) {\n        walkDOM(node, callback);\n        node = node.nextElementSibling;\n    }\n}\n","export function debounce(func, wait, immediate) {\n    var timeout;\n    return function () {\n        var context = this;\n        var args = arguments;\n        var later = function () {\n            timeout = null;\n            if (!immediate) {\n                func.apply(context, args);\n            }\n        };\n\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n}\n","export function asynDirectives(el) {\n    return new DirectiveManager(el);\n}\n\nclass DirectiveManager {\n    constructor(el) {\n        this.el = el;\n        this.directives = this.extractTypeModifiersAndValue();\n    }\n\n    all() {\n        return this.directives;\n    }\n\n    has(type) {\n        return this.directives.map(directive => directive.type).includes(type);\n    }\n\n    missing(type) {\n        return !this.has(type);\n    }\n\n    get(type) {\n        return this.directives.find(directive => directive.type === type);\n    }\n\n    extractTypeModifiersAndValue() {\n        return Array.from(this.el.getAttributeNames()\n\n        // FILTER ONLY THE ASYNergy DIRECTIVES\n        .filter(name => name.match(new RegExp('asyn:')))\n\n        // PARSE OUT THE TYPE, MODIFIERS, AND VALUE FROM IT\n        .map(name => {\n                const [type, ...modifiers] = name.replace(new RegExp('asyn:'), '').split('.');\n\n                return new Directive(type, modifiers, name, this.el);\n            }));\n    }\n}\n\nclass Directive {\n    constructor(type, modifiers, fullName, el) {\n        this.type = type;\n        this.modifiers = modifiers;\n        this.fullName = fullName;\n        this.el = el;\n        this.eventContext;\n        this.lcFunc = null;\n        this.emitEvent = false;\n    }\n\n    setEventContext(context) {\n        this.eventContext = context;\n    }\n    \n    get isEmitEvent() {\n      return emitEvent;\n    }\n    \n    set isEmitEvent(theBool) {\n      if (typeof theBool == \"boolean\") {\n        this.emitEvent = theBool;\n      }\n    }\n\n    get value() {\n        return this.el.getAttribute(this.fullName);\n    }\n    \n    get lcFunction() {\n      if (this.fullName === \"asyn:mutable\") {\n        const fullVal = this.el.getAttribute(this.fullName);\n\n        // GET LIVECODE FUNCTION TO BE CALLED\n        const pos = fullVal.search(/\\./);\n        if (pos !== -1) {\n            this.lcFunc = fullVal.split(\".\")[1];\n        }\n      }\n      return this.lcFunc;\n    }\n    \n    get modelValue() {\n      return this.el.value !== undefined ? this.el.value : this.el.innerText;\n    }\n\n    get handler() {\n      const { handler } = this.parseOutHandlerAndParams(this.value);\n      return handler;\n    }\n\n    get params() {\n      const { params } = this.parseOutHandlerAndParams(this.value);\n\n        return params;\n    }\n\n    durationOr(defaultDuration) {\n        let durationInMilliSeconds;\n        const durationInMilliSecondsString = this.modifiers.find(mod => mod.match(/([0-9]+)ms/));\n        const durationInSecondsString = this.modifiers.find(mod => mod.match(/([0-9]+)s/));\n\n        if (durationInMilliSecondsString) {\n            durationInMilliSeconds = Number(durationInMilliSecondsString.replace('ms', ''));\n        } else if (durationInSecondsString) {\n            durationInMilliSeconds = Number(durationInSecondsString.replace('s', '')) * 1000;\n        }\n\n        return durationInMilliSeconds || defaultDuration;\n    }\n\n    parseOutHandlerAndParams(rawHandler) {\n      let handler = rawHandler;\n        let params = [];\n        const handlerAndParamString = handler.match(/(.*?)\\((.*)\\)/s);\n\n        if (handlerAndParamString) {\n          handler = handlerAndParamString[1];\n\n            // USE A FUNCTION THAT RETURNS IT'S ARGUMENTS TO PARSE AND EVAL ALL PARAMS\n            // THIS \"$EVENT\" IS FOR USE INSIDE THE ASYNergy EVENT HANDLER\n            // ---------------- $event NOT USED ----------------------- //\n            let func = new Function('$event', `return (function () {\n              for (var l=arguments.length, p=new Array(l), k=0; k<l; k++) {\n                p[k] = arguments[k];\n              }\n              return [].concat(p);\n            })(${handlerAndParamString[2]})`);\n\n            params = func(this.eventContext);\n        }\n        return { handler, params };\n    }\n\n    cardinalDirectionOr(fallback = 'right') {\n        if (this.modifiers.includes('up')) {\n            return 'up';\n        }\n        if (this.modifiers.includes('down')) {\n            return 'down';\n        }\n        if (this.modifiers.includes('left')) {\n            return 'left';\n        }\n        if (this.modifiers.includes('right')) {\n            return 'right';\n        }\n        return fallback;\n    }\n\n    modelSyncDebounce(callback, time) {\n        // Prepare yourself for what's happening here.\n        // Any text input with asyn:model on it should be \"debounced\" by ~150ms by default.\n        // We can't use a simple debounce function because we need a way to clear all the pending\n        // debounces if a user submits a form or performs some other action.\n        // This is a modified debounce function that acts just like a debounce, except it stores\n        // the pending callbacks in a global property so we can \"clear them\" on command instead\n        // of waiting for their setTimeouts to expire.\n        if (!this.modelDebounceCallbacks) {\n            this.modelDebounceCallbacks = [];\n        }\n\n        // This is a \"null\" callback. Each asyn:model will register one of these upon initialization.\n        let callbackRegister = { callback: () => { } };\n\n        this.modelDebounceCallbacks.push(callbackRegister);\n\n        // This is a normal \"timeout\" for a debounce function.\n        var timeout;\n\n        return e => {\n            clearTimeout(timeout);\n\n            timeout = setTimeout(() => {\n                callback(e);\n                timeout = undefined;\n\n                // Because we just called the callback, let's return the\n                // callback register to it's normal \"null\" state.\n                callbackRegister.callback = () => { };\n            }, time);\n\n            // Register the current callback in the register as a kind-of \"escape-hatch\".\n            callbackRegister.callback = () => {\n                clearTimeout(timeout);\n                callback(e);\n            };\n        };\n    }\n}\n","export default class {\n    constructor(el, skipWatcher = false) {\n        this.el = el;\n        this.skipWatcher = skipWatcher;\n        this.updateQueue = [];\n    }\n}\n","import Action from '.';\n\nexport default class extends Action {\n    constructor(modelAttrVal, params, modelVal, isCustomEvent, el) {\n      super(el);\n\n      this.isCustomEvent = isCustomEvent;\n      this.type = 'fireEvent';\n      this.name = modelAttrVal;\n        this.payload = {\n            modelAttrVal,\n            params,\n            modelVal\n        };\n    }\n\n    // Overriding toId() becuase some EventActions don't have an \"el\"\n    toId() {\n        return btoa(encodeURIComponent(this.type, this.payload.event, JSON.stringify(this.payload.params)));\n    }\n}\n","export function dispatch(el, eventName, options, theHandler) {\n    const event = new CustomEvent(eventName, options);\n    el.addEventListener(eventName, theHandler);\n    el.dispatchEvent(event);\n}","\nexport default class MessageBus {\n    constructor() {\n        this.listeners = {};\n    }\n\n    register(name, callback) {\n        if (!this.listeners[name]) {\n            this.listeners[name] = [];\n        }\n\n        this.listeners[name].push(callback);\n    }\n\n    call(name, ...params) {\n        (this.listeners[name] || []).forEach(callback => {\n            callback(...params);\n        });\n    }\n\n    has(name) {\n        return Object.keys(this.listeners).includes(name);\n    }\n}\n","import MessageBus from './MessageBus';\n\nexport default {\n\tavailableHooks: [\n\t\t/**\n\t\t* Public Hooks\n\t\t*/\n\t\t'agent.initialized',\n\t\t'element.initialized',\n\t\t'element.updating',\n\t\t'element.updated',\n\t\t'element.removed',\n\t\t'message.sent',\n\t\t'message.failed',\n\t\t'message.received',\n\t\t'message.processed',\n\t\t'allMessages.processed',\n\t\t'request',\n\n\t\t/**\n\t\t* Private Hooks\n\t\t*/\n\t\t'interceptAsynModelSetValue',\n\t\t'interceptAsynModelAttachListener',\n\t\t'beforeReplaceState',\n\t\t'beforePushState'\n\t],\n\n  bus: new MessageBus(),\n\n  register(name, callback) {\n    if (!this.availableHooks.includes(name)) {\n      throw `ASYNergy: Referencing unknown hook: [${name}]`;\n    }\n\n    this.bus.register(name, callback);\n  },\n\n  call(name, ...params) {\n    this.bus.call(name, ...params);\n  }\n};\n","import EventAction from './action/event';  // ----------------------- temp test events\nimport { dispatch } from './util/dispatch'; // ------------------------------ temp test events\nimport HookManager from './HookManager';\nimport MessageBus from './MessageBus'; // -------- temp test events\nimport DirectiveManager from './DirectiveManager';\n// import Agent from './agent/index';\n\nconst store = {\n    csrf: {},\n    transmissionEls: [],\n    mutables: [],\n    directives: DirectiveManager,\n    asynergyIsInBackground: false,\n    asynergyIsOffline: false,\n    hooks: HookManager,\n    agents: [],\n    listeners: new MessageBus(),\n    nodesSetToDisabled: [],\n    nodesSetToReadOnly: [],\n    mutableIncludesModel: false,\n\n    theAgents() {\n      return Object.keys(this.agents).map(key => {\n        return this.agents[key];\n      });\n    },\n\n    registerHook(name, callback) {\n        this.hooks.register(name, callback);\n    },\n\n    callHook(name, ...params) {\n        this.hooks.call(name, ...params);\n    },\n\n    addAgent(agent) {\n        this.agents.push(agent);\n        return this.agents[this.agents.length - 1];\n    },\n\n    getAgentsByID(agentID) {\n      return this.agents.filter(agent => {\n        return agent.agentID === agentID;\n      });\n    },\n\n    tearDownAgents() {\n        let agentsLength = this.agents.length;\n        for (let i = 0; i < agentsLength; i++) {\n            let index = this.agents.length - 1;\n            this.removeAgent(this.agents[index], index);\n        }\n    },\n\n    emit(event, ...params) {\n      this.listeners.call(event, ...params);\n        this.agentsListeningForEvent(event).forEach(agent => {\n          agent.addAction(new EventAction(event, params));\n        });\n    },\n\n    agentsListeningForEvent(event) {\n        return this.theAgents().filter(agent => {\n          return agent.listeners.includes(event);\n        });\n    },\n    \n    addEmitEvent(el, directiveParams, handlerName, handler) {\n      let options = {};\n      const eventHandler = (...paramsA) => {\n        \n        const modelParams = [];\n        modelParams[0] = [];\n        let selectValues;\n        \n        if (paramsA !== undefined & paramsA.length !== 0) {\n          if (paramsA[0] !== undefined & paramsA[0].length !== 0) {\n            modelParams[0] = paramsA[0].split(',');\n          }\n\n          if (Array.isArray(paramsA) & (modelParams[0].toString() === directiveParams.toString())) {\n            \n            switch(el.type) {             \n              case 'text':\n                if (paramsA[1] !== undefined) {\n                  el.value = paramsA[1];\n                }\n\n                break;\n              \n              case 'checkbox':\n                if (paramsA[2] !== undefined) {\n                  el.checked = paramsA[2];\n                }\n                \n                break;\n\t\t\t\t\t\t\n              case 'radio':\n                if (paramsA[2] !== undefined) {\n                  el.checked = paramsA[2];\n                }\n                \n                break;\n\n              case 'range':\n                if (paramsA[1] !== undefined) {\n                  el.value = paramsA[1];\n                }\n                \n                break;\n                \n              case 'select-multiple':\n                if (paramsA[1] !== undefined) {\n                  selectValues = paramsA[1].split(',');\n                }\n                \n                if (selectValues !== undefined) {\n                  options.detail = selectValues;\n                }\n\n                for (const option of el.options) {\n                  if (selectValues.indexOf(option.value) !== -1) {\n                    option.setAttribute('selected', 'selected');\n                  } else {\n                    option.removeAttribute('selected');\n                  }\n                }\n                \n                break;\n\n              case 'submit':\n                if ( paramsA[1] !== undefined) {\n                  const modelValue = paramsA[1].split(',');\n                \n                  if (modelValue !== undefined) {\n                    options.detail = modelValue;\n                  }\n                }\n                \n                break;\n            }\n\n            dispatch(el, handlerName, options, handler);\n          }\n        } else { // if (paramsA !== undefined)\n          dispatch(el, handlerName, options, handler);\n        }\n      };\n      this.on(handlerName, eventHandler);\n    },\n\n    on(event, callback) {\n      this.listeners.register(event, callback);\n    },\n\n    removeAgent(agent, index) {\n        // Remove event listeners attached to the DOM.\n        agent.tearDown();\n        // Remove the component from the store.\n        // delete this.agents[index];\n        this.agents.splice(index, 1);\n    },\n\n      transmissionElsData(payload, listenerType, modelValueKey) {\n          if (this.transmissionEls[0] !== undefined) {\n            let index;\n            for (index = 0; index < this.transmissionEls.length; index++) {\n              if (this.transmissionEls[index].getAttribute('asyn:transmit') !== null) {\n\n                const transmissionElIsCheckbox = this.transmissionEls[index].type === 'checkbox';\n\t\t\t\t\t\t\tconst transmissionElIsRadio = this.transmissionEls[index].type === 'radio';\n                const transmissionElIsMutable = this.transmissionEls[index].mutable >= 0;\n\t\t\t\t\t\t\t\n                if (transmissionElIsCheckbox) {\n                    const isChecked = this.transmissionEls[index].checked;\n                    payload.transmissionElsData[this.transmissionEls[index].getAttribute('asyn:transmit')] = isChecked ? this.transmissionEls[index].value : 'false';\n\t\t\t\t\t\t\t\n\t              } else if (transmissionElIsRadio) {\n\t                  const isChecked = this.transmissionEls[index].checked;\n\t                  if (isChecked) {\n\t                      payload.transmissionElsData[this.transmissionEls[index].getAttribute('asyn:transmit')] = this.transmissionEls[index].value;\n\t                  }\n\t\t\t\t\t\t\t\n                } else {\n                    payload.transmissionElsData[this.transmissionEls[index].getAttribute('asyn:transmit')] = (this.transmissionEls[index].tagName === 'INPUT') || (this.transmissionEls[index].tagName === 'TEXTAREA') || (this.transmissionEls[index].tagName === 'SELECT') ? this.transmissionEls[index].value : this.transmissionEls[index].innerHTML;\n\n                    // REPLACE CHECKBOX MODEL VALUE WITH MUTABLE ELEMENT DATA\n                    if (listenerType === 'checkbox' && transmissionElIsMutable) {\n                        payload.modelData[modelValueKey] = this.transmissionEls[index].innerHTML;\n                    }\n\n                }\n              }\n            }\n        }\n        return payload;\n    },\n\n    addDisabledNode(theNode) {\n      this.nodesSetToDisabled.push(theNode);\n    },\n\n    addReadOnlyNode(theNode) {\n      this.nodesSetToReadOnly.push(theNode);\n    },\n\n    clearDisabledReadOnlyNodesArrays() {\n      let index;\n\n      for (index = 0; index < this.nodesSetToDisabled.length; index++) {\n        this.nodesSetToDisabled[index].disabled = false;\n      }\n      this.nodesSetToDisabled.length = 0;\n\n      for (index = 0; index < this.nodesSetToReadOnly.length; index++) {\n        this.nodesSetToReadOnly[index].readOnly = false;\n      }\n      this.nodesSetToReadOnly.length = 0;\n    },\n\n    mutabelsData(payload) {\n      if (this.mutables[0] !== undefined) {\n        let index;\n        for (index = 0; index < this.mutables.length; index++) {\n\n          payload.mutablesData[index] = {};\n          payload.mutablesData[index].mutableAttrVal = this.mutables[index].value;\n          payload.mutablesData[index].el = this.mutables[index].el;\n          payload.mutablesData[index].mutableInnerHTML = this.mutables[index].el.innerHTML;\n          payload.mutablesData[index].lcFunc = this.mutables[index].lcFunc;\n          payload.mutablesData[index].id = this.mutables[index].el.id;\n        }\n      } else {\n        payload.mutablesData = null;\n      }\n      \n      return payload;\n    }\n};\n\nexport default store;\n","import MessageBus from './MessageBus';\n\nexport default {\n    directives: new MessageBus(),\n\n    register(name, callback) {\n        if (this.has(name)) {\n            throw `ASYNergy: Directive already registered: [${name}]`;\n        }\n\n        this.directives.register(name, callback);\n    },\n\n    call(name, el, directive, mutableElem, url) {\n        this.directives.call(name, el, directive, mutableElem, url);\n    },\n\n    has(name) {\n        return this.directives.has(name);\n    }\n};\n","import Action from '.';\n\nexport default class extends Action {\n    constructor(modelAttrVal, params, modelVal, isCustomEvent, el, skipWatcher = false) {\n        super(el, skipWatcher);\n\n        this.isCustomEvent = isCustomEvent;\n        this.type = 'syncInput';\n        this.name = modelAttrVal;\n        this.payload = {\n            modelAttrVal,\n            params,\n            modelVal\n        };\n    }\n}\n","import DeferredModelAction from './deferred-model';\n\nexport default {\n  deferredActions: {},\n\n  addAction(name, value, el) {\n    if (!this.deferredActions[name]) {\n      new DeferredModelAction(name, value, el);\n      this.deferredActions[name] = [];\n    }\n\n    this.deferredActions[name].push(value);\n    this.deferredActions[name].push(el);\n  },\n\n  get deferredActionsData() {\n    let payloadDeferred = {};\n\n    if (this.deferredActions.length !== 0) {\n\n      // GET NAMES AND VALUES OF DEFERRED ACTIONS\n      for (let action in this.deferredActions) {\n        if (this.deferredActions.hasOwnProperty(action)) {\n          let actionData = this.deferredActions[action];\n\n          // actionData[0], IS THE INITIAL VALUE actionData[1] IS THE ELEMENT\n          // this.asynPayload[action] = actionData[1].value;\n          // USE THE ACTION SUFFIX AS PAYLOAD KEY\n\n          // REGULAR EXPRESSION (?<=(\\.)).+$ DOES NOT WORK WITH WEBKIT\n          // DUE TO LOOKBEHIND. WE USE (?:(\\.)).+$ AND STRIP THE FIRST\n          // CHARACTER, A DOT IN THIS CASE\n          // const actionSuffix = /(?<=(\\.)).+$/.exec(action);\n          // this.asynPayload[actionSuffix[0]] = actionData[1].value;\n          const actionExecResult = /(?:(\\.)).+$/.exec(action);\n          const actionSuffix = actionExecResult[0].substr(1);\n          payloadDeferred[actionSuffix] = actionData[1].value;\n        }\n      }\n    }\n    return payloadDeferred;\n  }\n};\n","import store from '../Store';\nimport Deferred from '../action/Deferred';\n\nexport default class Connection {\n\tconstructor(URL, updateEl, modelAttrVal, modelEl, event) {\n\t\tthis.url = URL;\n\t\tthis.updateEl = updateEl;\n\t\t// this.postKey = postKey;\n\t\tthis.modelAttrVal = modelAttrVal;\n\t\tthis.event = event;\n\t\tthis.action = this.ajax;\n\t\tthis.callback = this.completed_callback;\n\t\tthis.headers = {};\n\t\tthis.options = {};\n\t\tthis.options.headers = this.headers;\n\t\tthis.asynPayload = {};\n\t\tthis.mutablesData = [];\n\t\tthis.modelEl = modelEl;\n\t\tthis.actionType = '';\n\t\tthis.modelSyncTimeout = 1000;\n\t\tthis.isCustomEvent = undefined;\n\t\tthis.reregisterEvLis = false;\n\t}\n\t\t\n\t\t\n    onMessage(message, payload) {\n      message.agent.receiveMessage(message, payload);\n    }\n    \n    handleResponse(event, agent, responseObj, fetchedResponse) {\n      if (fetchedResponse !== true) {\n        this.event = event;\n        this.updateEl = agent.connection.updateEl;\n      };\n      \n      store.callHook('element.updating', this.updateEl, agent, event);\n\n      Object.values(responseObj.asynergyResponse).forEach(respItem => {\n        if (respItem.url !== undefined) {\n          location = respItem.url;\n          return;\n        }\n\n        if ((respItem.mutableVal === null) || (typeof(respItem.mutableVal) === \"object\") &&\n        (Object.keys(respItem.mutableVal).length === 0)) {\n          respItem.mutableVal = \"\";\n        }\n\n        if ((typeof respItem.mutableVal === \"string\") && (respItem.mutableVal.search(/asyn:/)) !== -1) {\n          this.reregisterEvLis = true;\n        }\n\n        this.updateEl.updated = 0;\n\n        this.updateMutablesByID(respItem);\n                \n        this.updateMutablesByAttrVal(respItem);\n                \n        if (this.updateEl.updated === 0) {\n          this.updateEl.innerHTML = respItem.mutableVal;\n        }\n                  \n        store.callHook('element.updated', this.updateEl, agent, this.event);\n                \n        this.syncModels(respItem);\n\n        store.callHook('message.processed', this.updateEl, agent, this.event);\n\n      });\n\n      if (this.reregisterEvLis === true) {\n        ASYNergy.reregisterEventListeners();\n      };\n\n    }\n\t\t\n\n    // FETCH COMPLETED ACTION //\n    completed_callback(msg) {\n\t\t\tstore.clearDisabledReadOnlyNodesArrays();\n\t\t\tstore.callHook('allMessages.processed', msg);\n    }\n    \n\n    ajax(message) {\n        const payload = message.payload();\n        const modelVal = payload.updates[0].payload.modelVal;\n        const listenerType = message.agent.el.type;\n        const modelParams = payload.updates[0].payload.params;\n\n        this.asynPayload = {};\n\n        this.asynPayload.modelData = {'modelAttrVal': this.modelAttrVal, 'modelVal': modelVal, 'modelParams': modelParams};\n\n        // CSRF\n        if (store.csrf.tokenName !== undefined && store.csrf.token !== '') {\n            this.asynPayload[store.csrf.tokenName] = store.csrf.token;\n        }\n        \n        // GET MUTABLE ELEMENTS DATA\n        this.asynPayload.mutablesData = [];\n        this.asynPayload = store.mutabelsData(this.asynPayload);\n        this.mutablesData = this.asynPayload.mutablesData;\n        \n        if (this.mutablesData === null) {\n          console.warn(\"Missing data of any mutable element!\");\n          return;\n        }\n        \n        if (this.updateEl === null) {\n          this.updateEl = this.mutablesData[0].el;\n        }\n        let index;\n\n        var mutableAttrVal = this.mutablesData[0].mutableAttrVal;\n\n        // GET TRANSMISSION ELEMENTS DATA\n        this.asynPayload.transmissionElsData = {};\n        this.asynPayload = store.transmissionElsData(this.asynPayload, listenerType, 'modelVal');\n\n        // GET DEFERRED MODEL ACTIONS\n        this.asynPayload.deferredModelData = Deferred.deferredActionsData;\n\n        this.asynPayload.actionType = message.updateQueue[0].type;\n        this.actionType = this.asynPayload.actionType;\n        \n        this.asynPayload.isCustomEvent = message.updateQueue[0].isCustomEvent;\n        this.isCustomEvent = this.asynPayload.isCustomEvent;\n\t\t\t\t\n\t\t\t store.callHook('request', this.options, this.mutablesData, this.asynPayload.modelData);\n\n        this.asynPayload = JSON.stringify(this.asynPayload);\n\n\n        fetch(this.url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-Requested-With': 'XMLHttpRequest',\n                'Accept': 'text/html, application/xhtml+xml',\n                'X-ASYNergy': true,\n\n                // SET CUSTOM HEADERS\n                ...(this.options.headers),\n\n                // WE'LL SET THIS EXPLICITLY TO MITIGATE POTENTIAL\n                // INTERFERENCE FROM AD-BLOCKERS/ETC.\n                'Referer': window.location.href\n            },\n            body: this.asynPayload\n        })   \n        .then(response => {\n            if (response.ok) {\n\n              response.text().then(response => {\n\n                const responseObj = JSON.parse(response);\n\n                this.onMessage(message, responseObj);\n                \n                const fetchedResponse = true;\n                \n                this.handleResponse(event, message.agent, responseObj, fetchedResponse);\n\n                this.callback(message);\n\n              });\n            }\n        })\n        \n        .catch((error) => {\n            console.error(error);\n          });\n    }\n    \n    // IF THE RESPONSE INCLUDES IDs OF MUTABLE ELEMENTS\n    // UPDATE ALL APPROPRIATE ELEMENTS\n    updateMutablesByID (responseObj) {\n      if ((responseObj.mutableID !== \"\") && \n      (responseObj.mutableID !== null)) {\n        const mutableID = responseObj.mutableID;\n        \n        if (typeof(mutableID) === \"object\") {\n          Object.values(mutableID).forEach(theID => {\n            this.updateEl = document.getElementById(`${theID}`);\n\n            this.updateEl.nodeName === \"INPUT\" ? this.updateEl.value = responseObj.mutableVal : this.updateEl.innerHTML = responseObj.mutableVal;\n            this.updateEl.updated = 1;\n          });\n        } else {\n          this.updateEl = document.getElementById(`${mutableID}`);\n          this.updateEl.nodeName === \"INPUT\" ? this.updateEl.value = responseObj.mutableVal : this.updateEl.innerHTML = responseObj.mutableVal;\n\n          this.updateEl.updated = 1;\n        }\n      }\n    }\n\n    // IF MULTIPLE MUTABLE ELEMENTS ARE SPECIFIED BY MUTABLE\n    // ATTRIBUTE VALUES IN THE RESPONSE, UPDATE ALL MUTABLE\n    // ELEMENTS THAT HAVE THE APPROPRIATE MUTABLE ATTRIBUTE VALUE\n    updateMutablesByAttrVal(responseObj) {\n      if (responseObj.mutableAttrVal !== \"\") {\n        if (this.mutablesData.length > 0) {\n          let attrValFragments = [];\n          let attrValPrefix = '';\n          this.mutablesData.forEach(mutable => {\n            const compoundAttrVal = mutable.mutableAttrVal.search(/[.]/);\n            if (compoundAttrVal !== -1) {\n              attrValFragments = /^.+(?=(\\.))/.exec(mutable.mutableAttrVal);\n              attrValPrefix = attrValFragments[0];\n            }\n\n            if ((mutable.mutableAttrVal === responseObj.mutableAttrVal) || \n                (mutable.mutableAttrVal === attrValPrefix) || \n                (Object.values(responseObj.mutableAttrVal).indexOf(mutable.mutableAttrVal) > -1)) {\n              this.updateEl = mutable.el;\n\n              this.updateEl.nodeName === \"INPUT\" ? this.updateEl.value = responseObj.mutableVal : this.updateEl.innerHTML = responseObj.mutableVal;\n              this.updateEl.updated = 1;\n            }\n            \n          });\n        }\n      }\n    }\n    \n    // SYNCHRONIZE ANY MODEL TO THE DATA OF THE MUTABLE ELEMENT\n    syncModels(responseObj) {\n      if ((responseObj.syncModelID !== \"\") && \n      (responseObj.syncModelID !== null)) {\n        let modelID = responseObj.syncModelID;\n\n        if (this.actionType === \"syncInput\") {\n          // SYNCHRONIZING NEEDS A DELAY, OTHERWISE SOME INPUT MAY BE LOST\n          let timer;\n          const model = document.getElementById(`${modelID}`);\n          const mutableEl = this.updateEl;\n          const timeOut = this.modelSyncTimeout;\n\n          if (model.getAttribute('listener') !== 'true') {\n            model.value = mutableEl.innerHTML;\n          }\n\n          model.addEventListener(\"input\", function (e) {\n            model.setAttribute('listener', 'true');\n            clearTimeout(timer);\n            timer = setTimeout(() => {\n              model.value = mutableEl.innerHTML;\n              model.removeAttribute('listener');\n            }, timeOut);\n          });\n          \n        } else {\n          \n          const modelID = responseObj.syncModelID;\n          \n          // IF modelID IS AN OBJECT, THEN THERE ARE MULTIPLE OBJECTS TO BE SYNCED\n          if (typeof(modelID) === \"object\") {\n            Object.values(modelID).forEach(theID => {\n              document.getElementById(`${theID}`).value = responseObj.mutableVal;\n            });\n          } else {\n            // THERE IS ONLY ONE MODEL TO BE SYNCED\n            document.getElementById(`${modelID}`).value = responseObj.mutableVal; // ?????????????\n          }\n        }\n      }\n    }\n}\n","import { asynDirectives } from '../util/asynDirectives';\n\n/**\n * This is intended to isolate all native DOM operations. The operations that happen\n * one specific element will be instance methods, the operations you would normally\n * perform on the \"document\" (like \"document.querySelector\") will be static methods.\n */\nexport default {\n    allModelElementsInside(root) {\n        return Array.from(root.querySelectorAll(`[asyn\\\\:model]`));\n    },\n\n    getByAttributeAndValue(attribute, value) {\n        return document.querySelector(`[asyn\\\\:${attribute}=\"${value}\"]`);\n    },\n\n    hasAttribute(el, attribute) {\n        return el.hasAttribute(`asyn:${attribute}`);\n    },\n\n    getAttribute(el, attribute) {\n        return el.getAttribute(`asyn:${attribute}`);\n    },\n\n    removeAttribute(el, attribute) {\n        return el.removeAttribute(`asyn:${attribute}`);\n    },\n\n    setAttribute(el, attribute, value) {\n        return el.setAttribute(`asyn:${attribute}`, value);\n    },\n\n    hasFocus(el) {\n        return el === document.activeElement;\n    },\n\n    isInput(el) {\n        return ['INPUT', 'TEXTAREA', 'SELECT'].includes(\n            el.tagName.toUpperCase()\n        );\n    },\n\n    isTextInput(el) {\n        return (\n            ['INPUT', 'TEXTAREA'].includes(el.tagName.toUpperCase()) &&\n            !['checkbox', 'radio'].includes(el.type)\n  );\n    },\n\n    valueFromInput(el, agent) {\n        if (el.type === 'checkbox') {\n            let modelName = asynDirectives(el).get('model').value;\n            // If there is an update from asyn:model.defer in the chamber,\n            // we need to pretend that is the actual data from the server.\n            let modelValue = agent.deferredActions[modelName]\n                ? agent.deferredActions[modelName].asynPayload.value\n                // : get(agent.data, modelName);\n                : el.checked;\n\n            if (Array.isArray(modelValue)) {\n                return this.mergeCheckboxValueIntoArray(el, modelValue);\n            }\n\n            if (el.checked) {\n                return el.getAttribute('value') || true;\n            } else {\n                return false;\n            }\n        } else if (el.tagName === 'SELECT' && el.multiple) {\n            return this.getSelectValues(el);\n        }\n\n        return el.value;\n    },\n\n    mergeCheckboxValueIntoArray(el, arrayValue) {\n        if (el.checked) {\n            return arrayValue.includes(el.value)\n                ? arrayValue\n                : arrayValue.concat(el.value);\n        }\n\n        return arrayValue.filter(item => item != el.value);\n    },\n      \n      setInputValueFromModel(el, agent) {\n          const modelString = asynDirectives(el).get('model').value;\n          const modelValue = get(agent.data, modelString);\n\n          // Don't manually set file input's values.\n          if (\n              el.tagName.toLowerCase() === 'input' &&\n              el.type === 'file'\n          )\n              return;\n\n          this.setInputValue(el, modelValue);\n      },\n\n    setInputValue(el, value) {\n        if (el.type === 'radio') {\n            el.checked = el.value == value;\n        } else if (el.type === 'checkbox') {\n            if (Array.isArray(value)) {\n                // I'm purposely not using Array.includes here because it's\n                // strict, and because of Numeric/String mis-casting, I\n                // want the \"includes\" to be \"fuzzy\".\n                let valueFound = false;\n                value.forEach(val => {\n                    if (val == el.value) {\n                        valueFound = true;\n                    }\n                });\n\n                el.checked = valueFound;\n            } else {\n                el.checked = !!value;\n            }\n        } else if (el.tagName === 'SELECT') {\n            this.updateSelect(el, value);\n        } else {\n            value = value === undefined ? '' : value;\n\n            el.value = value;\n        }\n    },\n\n    getSelectValues(el) {\n        return Array.from(el.options)\n          .filter(option => option.selected)\n          .map(option => option.value || option.text);\n    },\n\n    updateSelect(el, value) {\n        const arrayWrappedValue = [].concat(value).map(value => value + '');\n\n        Array.from(el.options).forEach(option => {\n            option.selected = arrayWrappedValue.includes(option.value);\n        });\n    }\n};\n","import Action from '.';\n\nexport default class extends Action {\n    constructor(modelAttrVal, params, modelVal, isCustomEvent, el, skipWatcher = false) {\n        super(el, skipWatcher);\n\n        this.isCustomEvent = isCustomEvent;\n        this.type = 'callHandler';\n        this.name = modelAttrVal;\n        this.payload = {\n            modelAttrVal,\n            params,\n            modelVal\n        };\n    }\n\n}","import Action from '.';\n\nexport default class extends Action {\n    constructor(modelAttrVal, params, modelVal, isCustomEvent, el) {\n        super(el);\n\n        this.isCustomEvent = isCustomEvent;\n        this.type = 'syncInput';\n        this.name = modelAttrVal;\n        this.payload = {\n            // id: this.signature,\n            modelAttrVal,\n            params,\n            modelVal\n        };\n    }\n}\n","export default class {\n    constructor(agent, updateQueue) {\n        this.agent = agent;\n        this.updateQueue = updateQueue;\n    }\n\n    payload() {\n        return {\n            // This ensures only the type & payload properties only get sent over.\n            updates: this.updateQueue.map(update => ({\n                type: update.type,\n                payload: update.payload\n            }))\n        };\n    }\n\n    storeResponse(payload) {\n      return (this.response = payload);\n    }\n\n}\n","import Message from '../Message';\nimport { debounce } from '../util/debounce';\nimport store from '../Store';\nimport DeferredModelAction from '../action/deferred-model';\nimport { walkDOM } from '../util/walkDOM';\nimport MessageBus from '../MessageBus';\n\nexport default class {\n    constructor(el, connection, postValue, agentID) {\n        this.el = el;\n        this.updateQueue = [];\n        this.deferredActions = {}; // temp test\n        this.messageInTransit = undefined;\n        this.connection = connection;\n        this.postValue = postValue;\n        this.agentID = agentID;\n        this.tearDownCallbacks = [];\n        this.scopedListeners = new MessageBus();\n        this.listeners = [];\n        store.callHook('agent.initialized', this);\n    }\n\n    on(event, callback) {\n      this.scopedListeners.register(event, callback);\n    }\n\n    addAction(action) {\n        if (action instanceof DeferredModelAction) {\n            this.deferredActions[action.name] = action;\n\n            return;\n        }\n\n        this.updateQueue.push(action);\n\n        // This debounce is here in-case two events fire at the \"same\" time:\n        // For example: if you are listening for a click on element A,\n        // and a \"blur\" on element B. If element B has focus, and then,\n        // you click on element A, the blur event will fire before the \"click\"\n        // event. This debounce captures them both in the actionsQueue and sends\n        // them off at the same time.\n        // Note: currently, it's set to 5ms, that might not be the right amount, we'll see.\n        debounce(this.fireMessage, 5).apply(this);\n\n        // Clear prefetches.\n        // this.prefetchManager.clearPrefetches()\n    }\n\n    fireMessage() {\n        Object.entries(this.deferredActions).forEach(([modelName, action]) => {\n          this.updateQueue.unshift(action);\n        });\n        this.deferredActions = {};\n\n        this.messageInTransit = new Message(this, this.updateQueue);\n\n      let sendMessage = () => {\n        this.connection.action(this.messageInTransit);\n\n        store.callHook('message.sent', this, this.messageInTransit);\n\n        this.updateQueue = [];\n      };\n        sendMessage();\n    }\n\n    receiveMessage(message, payload) {\n      message.storeResponse(payload);\n\n        // This bit of logic ensures that if actions were queued while a request was\n        // out to the server, they are sent when the request comes back.\n        if (this.updateQueue.length > 0) {\n          this.fireMessage();\n        }\n    }\n    \n    doReplayResponse(event, agent, response) {\n      this.connection.handleResponse(event, agent, response);\n    }\n\n    walk(callback, callbackWhenNewComponentIsEncountered = el => { }) {\n      walkDOM(this.el, el => {\n        // Skip the root component element.\n        if (el.isSameNode(this.el)) {\n          callback(el);\n          return;\n        }\n\n        if (callback(el) === false) {\n          return false;\n        }\n      });\n    }\n\n    callAfterModelDebounce(callback) {\n        // This is to protect against the following scenario:\n        // A user is typing into a debounced input, and hits the enter key.\n        // If the enter key submits a form or something, the submission\n        // will happen BEFORE the model input finishes syncing because\n        // of the debounce. This makes sure to clear anything in the debounce queue.\n\n        if (this.modelDebounceCallbacks) {\n            this.modelDebounceCallbacks.forEach(callbackRegister => {\n                callbackRegister.callback();\n                callbackRegister.callback = () => { };\n            });\n        }\n\n      callback();\n    }\n\n    addListenerForTeardown(teardownCallback) {\n        this.tearDownCallbacks.push(teardownCallback);\n    }\n\n    tearDown() {\n        this.tearDownCallbacks.forEach(callback => callback());\n    }\n}\n","import { debounce } from './util/debounce';\nimport { kebabCase } from './util';\nimport { asynDirectives } from './util/asynDirectives';\nimport Connection from './connection/index';\nimport DOM from './dom/dom';\nimport HandlerAction from './action/handler';\nimport store from './Store';\nimport ModelAction from './action/model';\nimport DeferredModelAction from './action/deferred-model';\nimport Deferred from './action/Deferred';\nimport Agent from './agent/index';\n\nexport default {\n\n    initialize(el, url, reregisterEvl) {\n        let isAgent = false;\n        asynDirectives(el).all().forEach(directive => {\n            let test;\n            let lcFunc;\n            switch (directive.type) {\n\n            case 'model': {\n                if (!directive.value) {\n                    console.warn('ASYNergy: [asyn:model] is missing a value.', el);\n\n                    break;\n                }\n\n                // CHECK FOR COMPUND MODEL ATTRIBUTE VALUE, USE THE PREFIX\n                // TO CHECK IF THERE IS A CORRESPONDING MUTABLE ELEMENT\n                let directiveVal = '';\n                let compoundAttrVal = directive.value.search(/[.]/);\n                if (compoundAttrVal !== -1) {\n                    const dirValPrefix = /^.+(?=(\\.))/.exec(directive.value);\n                    directiveVal = dirValPrefix[0];\n                } else {\n                    directiveVal = directive.value;\n                }\n\t\t\t\t\t\t\t\n                // GET RID OF THE MODEL PARAMETERS\n                compoundAttrVal = directive.value.search(/[\\(]/);\n                \n                if (compoundAttrVal !== -1) {\n                  const dirVal = /^.+(?=(\\())/.exec(directive.value);\n                  directiveVal = dirVal[0];\n                }\n\n                let mutableElem = document.querySelector(`[asyn\\\\:mutable=${directiveVal}]`);\n\n                // GET ATTRIBUTE\n                let attr = this.modelAttr(directive.fullName, directiveVal);               \n                let modelElem = document.querySelector(`[${attr}]`);\n\n                if (mutableElem !== null) {\n                  this.attachModelListener(el, directive, mutableElem, url, modelElem, directiveVal);\n                } else {\n                    mutableElem = document.querySelector(`[asyn\\\\:mutable^=${directiveVal}\\\\.]`);\n                    if (mutableElem !== null) {\n                      this.attachModelListener(el, directive, mutableElem, url, modelElem, directiveVal);\n                    } else {\n                        console.warn(\n                        'ASYNergy: [asyn:model] is missing a corresponding [asyn:mutable] element.',\n                        el);\n                    }\n                }\n\n                test = 'model';\n                isAgent = true;\n                break;\n            }\n\n            case 'mutable':\n              if (reregisterEvl !== true) {\n\n                if ((typeof directive.el.innerHTML === \"string\") && (directive.el.innerHTML.search(/asyn:/)) !== -1) {\n                  store.mutableIncludesModel = true;\n                }\n\n                lcFunc = directive.lcFunction;\n                store.mutables.push(directive);\n\n                test = 'mutable';\n                isAgent = false;\n              }\n            break;\n\n            case 'transmit':\n                // CHECK IF ELEMENT IS A MUTABLE ELEMENT, NEEDED TO\n                // REPLACE A MODEL CHECKBOX VALUE WITH THE MODEL INPUT VALUE\n                directive.el.mutable = el.getAttributeNames().indexOf('asyn:mutable');\n\n                store.transmissionEls.push(directive.el);\n\n                test = 'transmit';\n                isAgent = true;\n                break;\n\n            case 'csrf':\n                store.csrf.tokenName = directive.value;\n                store.csrf.token = el.value;\n\n                test = 'csrf';\n                isAgent = false;\n                break;\n\n            default:\n              const params = directive.params;\n              let handler = directive.value;\n              if (params.length !== 0) {\n                handler = directive.handler;\n              }\n\n                let mutableElem = document.querySelector(`[asyn\\\\:mutable=${handler}]`);\n                if (mutableElem === null) {\n                    mutableElem = document.querySelector(`[asyn\\\\:mutable^=${handler}\\\\.]`);\n                }\n\n                // GET ATTRIBUTE\n                let attr = this.modelAttr(directive.fullName, directive.value);\n                let modelElem = document.querySelector(`[${attr}]`);\n\n                if (store.directives.has(directive.type)) {\n                    store.directives.call(\n                      directive.type,\n                      el,\n                      directive,\n                      mutableElem,\n                      url\n                          );\n                }\n\n                this.attachDomListener(el, directive, mutableElem, url, modelElem);\n\n                test = 'default';\n                isAgent = true;\n                break;\n        }\n\n        });\n\n        if (isAgent === true) {\n            let index = store.agents.length - 1;\n            let theAgent = store.agents[index];\n            let eventType = theAgent.connection.event;\n            store.callHook('element.initialized', el, theAgent, eventType);\n        }\n        isAgent = false;\n    },\n\n    attachModelListener(el, directive, mutableEl, url, modelEl, modelAttrVal) {\n        const isLazy = directive.modifiers.includes('lazy');\n\n        //---------------------------------------\n        // Slider control directive to update the current value in real time\n        // without sending requests while the user moves the slider.\n        // Request is sent when the user releases the slider.\n        // Example: asyn:model.lazy=\"slider('displayValue','%')\"\n        if (el.type === \"range\" && isLazy && directive.value.match(/\\bdisplayValue\\b/) !== null) {\n          let sliderElement = el;\n          let sliderValueElement = mutableEl;\n          let valUnit = '';\n\n          let directiveValues = directive.value;\n\n          // Regular expression pattern to match strings enclosed in single quotes\n          let regex = /'(.*?)'/g;\n\n          let matches = [];\n          let match;\n          while (match = regex.exec(directiveValues)) {\n            matches.push(match[1]);\n          }\n          if (matches[1] !== undefined) {\n            valUnit = matches[1];\n          }\n\n          sliderElement.oninput = () => {\n            sliderValueElement.innerHTML = sliderElement.value + valUnit;\n          }\n        };\n        //---------------------------------------\n\n        const debounceIf = (condition, callback, time) =>\n          condition ? directive.modelSyncDebounce(callback, time) : callback;\n\n        const hasDebounceModifier = directive.modifiers.includes('debounce');\n\n      store.callHook('interceptAsynModelAttachListener', directive, el, mutableEl);\n\n        let event = el.tagName.toLowerCase() === 'select'\n        || ['checkbox', 'radio'].includes(el.type)\n        || directive.modifiers.includes('lazy') ? 'change' : 'input';\n        \n        if (el.tagName.toLowerCase() === 'input' && directive.modifiers.includes('blur')) {\n          event = 'blur';\n        }\n\n        let model = modelAttrVal;\n\n        // TODO check for trailing slashes\n        const handlerURL = url + '/' + model;\n      const initConnection = new Connection(handlerURL, mutableEl, model, modelEl, event);\n\n        const connect = {\n            sendMessage: function () {\n                // INPUT FIELD VALUE\n                let postValue = el.value;\n                initConnection.action(postValue);\n            }\n        };\n\n        let agentID = store.agents.length + 1;\n        let agent = store.addAgent(new Agent(el, initConnection, el.value, agentID));\n\n        if (directive.modifiers.includes('defer')) {\n            Deferred.addAction(directive.value, el.value, el);\n        }\n\n        // If it's a text input and not .lazy, debounce, otherwise fire immediately.\n        let handler = debounceIf(hasDebounceModifier || (DOM.isTextInput(el) && !isLazy), e => {\n            let model = directive.value;\n            let params = directive.params;\n            let el = e.target;\n\n            const isCustomEvent = e instanceof CustomEvent;\n\n            isCustomEvent ? directive.emitEvent = true : directive.emitEvent = false;\n\n            let modelVal = e instanceof CustomEvent\n                // We have to check for typeof e.detail here for IE 11.\n                && typeof e.detail != 'undefined'\n                && typeof window.document.documentMode == 'undefined'\n                    // With autofill in Safari, Safari triggers a custom event and assigns\n                    // the value to e.target.value, so we need to check for that value as well.\n                    ? e.detail || e.target.value\n                    : DOM.valueFromInput(el, agent);\n\n            if (directive.modifiers.includes('defer')) {\n                agent.addAction(new DeferredModelAction(model, params, modelVal, isCustomEvent, el));\n            } else {\n                agent.addAction(new ModelAction(model, params, modelVal, isCustomEvent, el));\n            }\n        }, directive.durationOr(150));\n\n        store.addEmitEvent(el, directive.params, directive.handler, handler);\n\n        el.addEventListener(event, handler);\n\n        agent.addListenerForTeardown(() => {\n          el.removeEventListener(event, handler);\n        });\n\n        // Taken from: https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n      let isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\n        // Safari is weird and doesn't properly fire input events when\n        // a user \"autofills\" a asyn:model(.lazy) field. So we are\n        // firing them manually for assurance.\n      isSafari && el.addEventListener('animationstart', e => {\n        if (e.animationName !== 'asynergyAutofill') {\n          return;\n        }\n\n        e.target.dispatchEvent(new Event('change', { bubbles: true }));\n        e.target.dispatchEvent(new Event('input', { bubbles: true }));\n      });\n    },\n\n    attachDomListener(el, directive, mutableEl, url, modelEl) {\n        switch (directive.type) {\n        case 'keydown':\n        case 'keyup':\n\n            this.attachListener(el, directive, e => {\n                // Detect system modifier key combinations if specified.\n                const systemKeyModifiers = [\n                 'ctrl',\n                 'shift',\n                 'alt',\n                 'meta',\n                 'cmd',\n                 'super'\n                ];\n                const selectedSystemKeyModifiers = systemKeyModifiers.filter(\n                       key => directive.modifiers.includes(key)\n                   );\n\n                if (selectedSystemKeyModifiers.length > 0) {\n                    const selectedButNotPressedKeyModifiers = selectedSystemKeyModifiers.filter(\n                      key => {\n                                // Alias \"cmd\" and \"super\" to \"meta\"\n                                if (key === 'cmd' || key === 'super') {\n                                    key = 'meta';\n                                }\n                                return !e[`${key}Key`];\n                            }\n                       );\n\n                    if (selectedButNotPressedKeyModifiers.length > 0) {\n                        return false;\n                    }\n                }\n\n                // Handle spacebar\n                if (e.keyCode === 32 || (e.key === ' ' || e.key === 'Spacebar')) {\n                    return directive.modifiers.includes('space');\n                }\n\n                // Strip 'debounce' modifier and time modifiers from modifiers list\n                let modifiers = directive.modifiers.filter(modifier =>\n                        (\n                           !modifier.match(/^debounce$/) &&\n                           !modifier.match(/^[0-9]+m?s$/)\n                       )\n                   );\n\n                // Only handle listener if no, or matching key modifiers are passed.\n                // It's important to check that e.key exists - OnePassword's extension\n                // does weird things.\n                return Boolean(modifiers.length ===\n                  0 || (e.key && modifiers.includes(kebabCase(e.key))));\n            }, mutableEl, url, modelEl);\n\n            break;\n        case 'click':\n\n            this.attachListener(el, directive, e => {\n                // We only care about elements that have the .self modifier on them.\n                if (!directive.modifiers.includes('self')) {\n                    return;\n                }\n\n                // This ensures a listener is only run if the event originated\n                // on the elemenet that registered it (not children).\n                // This is useful for things like modal back-drop listeners.\n              return el.isSameNode(e.target);\n            }, mutableEl, url, modelEl);\n\n            break;\n        default:\n            this.attachListener(el, directive, e => el === e.target, mutableEl, url, modelEl);\n            break;\n    \t\t\t}\n    },\n\n    attachListener(el, directive, callback, mutableEl, url, modelEl) {\n        const event = directive.type;\n        const model = directive.handler;\n\n        // TODO check for trailing slashes\n        const handlerURL = url + '/' + model;\n\n        const initConnection = new Connection(handlerURL, mutableEl, model, modelEl, event);\n\n        let postValue = () => {\n            return el.value !== undefined ? el.value : el.innerText;\n        };\n\n        let agentID = store.agents.length + 1;\n        let agent = store.addAgent(new Agent(el, initConnection, postValue(), agentID));\n\n        const handler = e => {\n            if (callback && callback(e) === false) {\n                return;\n            }\n            \n            const isCustomEvent = e instanceof CustomEvent;\n\n          agent.callAfterModelDebounce(() => {\n            const el = e.target;\n\n            directive.setEventContext(e);\n\n            // This is outside the conditional below so \"asyn:click.prevent\"\n            // without a value still prevents default.\n            this.preventAndStop(e, directive.modifiers);\n            const handler = directive.handler;\n            let params = directive.params;\n            let modelVal = directive.modelValue;\n\n            if (isCustomEvent) {\n              directive.emitEvent = true;\n              if (e.detail !== undefined) {\n                modelVal = e.detail;\n              }\n            } else {\n              directive.emitEvent = false;\n            }\n\n            if (\n              params.length === 0 &&\n              isCustomEvent &&\n              e.detail\n            ) {\n              params.push(e.detail);\n            }\n\n            if (directive.value) {\n              agent.addAction(new HandlerAction(handler, params, modelVal, isCustomEvent, el));\n            }\n\n          });\n        };\n\n        const debounceIf = (condition, callback, time) =>\n          condition ? debounce(callback, time) : callback;\n\n        const hasDebounceModifier = directive.modifiers.includes('debounce');\n        const debouncedHandler = debounceIf(\n           hasDebounceModifier,\n           handler,\n           directive.durationOr(150)\n        );\n\n        store.addEmitEvent(el, directive.params, directive.handler, handler);\n\n        el.addEventListener(event, debouncedHandler);\n\n        agent.addListenerForTeardown(() => {\n          el.removeEventListener(event, debouncedHandler);\n        });\n    },\n    \n    preventAndStop(event, modifiers) {\n      modifiers.includes('prevent') && event.preventDefault();\n      modifiers.includes('stop') && event.stopPropagation();\n    },\n\n    modelAttr(fullName, attrVal) {\n      let escFullName = this.escapedStr(fullName);\n      let escAttrVal = this.escapedStr(attrVal);\n      let attr = escFullName + \"=\" + \"\\\"\" + escAttrVal + \"\\\"\";\n      return attr;\n    },\n    \n    escapedStr(str) {\n      let escapedStr = str;\n      escapedStr = escapedStr.replace(/\\:|\\.|\"|'/gi, function (x) {\n        return \"\\\\\" + x;\n      });\n      return escapedStr;\n    }\n};\n","\nexport * from './debounce';\nexport * from './asynDirectives';\nexport * from './walkDOM';\n\nexport function kebabCase(subject) {\n    return subject.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[_\\s]/, '-').toLowerCase();\n}\n\nexport function tap(output, callback) {\n    callback(output);\n\n    return output;\n}\n","import store from '../Store';\nimport { asynDirectives } from '../util/asynDirectives';\n\nlet cleanupStackByAgentId = {};\n\nexport default function () {\n  store.registerHook('element.initialized', (el, agent) => {\n    let directives = asynDirectives(el);\n\n    if (directives.missing('submit')) return;\n\n    // Set a forms \"disabled\" state on inputs and buttons.\n    // ASYNergy will clean it all up automatically submitting the form.\n    el.addEventListener('submit', () => {\n      cleanupStackByAgentId[agent.agentID] = [];\n\n      agent.walk(node => {\n        if (!el.contains(node)) return;\n\n        if (node.hasAttribute('asyn:ignore')) return false;\n\n        if (\n          // <button type=\"submit\">\n          (node.tagName.toLowerCase() === 'button' &&\n            node.type === 'submit') ||\n          // <select>\n          node.tagName.toLowerCase() === 'select' ||\n          // <input type=\"checkbox|radio\">\n          (node.tagName.toLowerCase() === 'input' &&\n            (node.type === 'checkbox' || node.type === 'radio'))\n        ) {\n\n          if (!node.disabled)\n            cleanupStackByAgentId[agent.agentID].push(\n              () => (node.disabled = false)\n            );\n\n          node.disabled = true;\n          // TODO: add node to disabled nodes array ---------------------------\n          store.addDisabledNode(node);\n        } else if (\n          // <input type=\"text\">\n          node.tagName.toLowerCase() === 'input' ||\n          // <textarea>\n          node.tagName.toLowerCase() === 'textarea'\n        ) {\n          if (!node.readOnly)\n            cleanupStackByAgentId[agent.agentID].push(\n              () => (node.readOnly = false)\n            );\n\n          node.readOnly = true;\n          // TODO: add node to readOnly nodes array ---------------------------\n          store.addReadOnlyNode(node);\n        }\n      });\n    });\n  });\n\n  store.registerHook('message.failed', (message, agent) => cleanup(agent));\n  store.registerHook('message.received', (message, agent) => cleanup(agent));\n}\n\nfunction cleanup(agent) {\n    if (!cleanupStackByAgentId[agent.agentID]) return;\n\n    while (cleanupStackByAgentId[agent.agentID].length > 0) {\n      cleanupStackByAgentId[agent.agentID].shift()();\n    }\n}\n","import store from '../Store';\nimport Message from '../Message';\n\nexport default function () {\n\n\tlet initializedPath = false;\n\n\tlet agentIdsThatAreWritingToHistoryState = new Set;\n\n\tASYNergyStateManager.clearState();\n    \n\tlet browserHistoryOn = false;\n    \n\tstore.registerHook('agent.initialized', agent => {\n\t\tif (store.mutableIncludesModel === true) {\n        \n\t\t\tif (initializedPath === false) {\n              \n\t\t\t\tlet url = window.location.href;\n              \n\t\t\t\tlet responseItemNum = 0;\n              \n\t\t\t\tlet asynergyResponse = {};\n              \n\t\t\t\tfor (const mutablesItem in store.mutables) {\n\t\t\t\t\tresponseItemNum += 1;\n\n\t\t\t\t\tasynergyResponse[responseItemNum] = {\n\t\t\t\t\t\tmutableID: store.mutables[mutablesItem].el.id,\n\t\t\t\t\t\tsyncModelID: \"\",\n\t\t\t\t\t\tmutableVal: store.mutables[mutablesItem].el.innerHTML,\n\t\t\t\t\t\tmutableAttrVal: store.mutables[mutablesItem].el.getAttribute('asyn:mutable'),\n\t\t\t\t\t};\n\t\t\t\t};\n              \n\t\t\t\tlet response = {\n\t\t\t\t\tasynergyResponse\n\t\t\t\t};\n\n\t\t\t\tASYNergyStateManager.replaceState(url, response, agent);\n\n\t\t\t\tagentIdsThatAreWritingToHistoryState.add(agent.agentID);\n\n\t\t\t\tinitializedPath = true;\n\t\t\t\tbrowserHistoryOn = true;\n\t\t\t};\n\t\t};\n\t});\n\n\n\tstore.registerHook('allMessages.processed', (message) => {\n\t\tif (browserHistoryOn === true) {\n\t\t\t// Preventing a circular dependancy.\n\t\t\tif (message.replaying) return;\n\n\t\t\tlet { response } = message;\n\n\t\t\tlet effects = response.effects || {};\n\n\t\t\tlet url = window.location.href;\n\t\t\tASYNergyStateManager.pushState(url, response, message.agent);\n\n\t\t};\n\t});\n\n\n\twindow.addEventListener('popstate', event => {\n\t\tif (browserHistoryOn === true) {\n        \n\t\t\tif (ASYNergyStateManager.missingState(event)) return;\n\n\t\t\tASYNergyStateManager.replayResponses(event, (response, agent) => {\n \n\t\t\t\tlet updateEl = agent.connection.updateEl;\n\t\t\t\tlet message = new Message(agent, []);\n\n\t\t\t\tmessage.storeResponse(response);\n\n\t\t\t\tmessage.replaying = true;\n\n\t\t\t\tagent.doReplayResponse(event, agent, response);\n\t\t\t});\n\t\t};\n\t});\n}\n\n\nlet ASYNergyStateManager = {\n    replaceState(url, response, agent) {\n\t\t\tthis.updateState('replaceState', url, response, agent);\n    },\n\n    pushState(url, response, agent) {\n\t\t\tthis.updateState('pushState', url, response, agent);\n    },\n\n    updateState(method, url, response, agent) {\n\t\t\tlet state = this.currentState();\n\n\t\t\tstate.storeResponse(response, agent);\n\n\t\t\tlet stateArray = state.toStateArray();\n\n        // Copy over existing history state if it's an object, so we don't overwrite it.\n\t\t\tlet fullstateObject = Object.assign(history.state || {}, { ASYNergy: stateArray });\n\n\t\t\tlet capitalize = subject => subject.charAt(0).toUpperCase() + subject.slice(1);\n\n\t\t\tstore.callHook('before'+capitalize(method), fullstateObject, url, agent);\n\n        try {\n            if (decodeURI(url) != 'undefined') {\n\t\t\t\t\t\t\turl = decodeURI(url).replaceAll(' ', '+').replaceAll('\\\\', '%5C');\n            }\n\n            history[method](fullstateObject, '', url);\n\n        } catch (error) {\n            // Firefox has a 160kb limit to history state entries.\n            // If that limit is reached, we'll instead put it in\n            // sessionStorage and store a reference to it.\n            if (error.name === 'NS_ERROR_ILLEGAL_VALUE') {\n\t\t\t\t\t\t\tlet key = this.storeInSession(stateArray);\n\n\t\t\t\t\t\t\tfullstateObject.asynergy = key;\n\n\t\t\t\t\t\t\thistory[method](fullstateObject, '', url);\n\n            } else {\n              console.error('history.' + method + ': ' + error);\n            };\n        };\n    },\n\n    replayResponses(event, callback) {\n        if (! event.state.ASYNergy) return;\n\n        let state = typeof event.state.ASYNergy === 'string'\n            ? new ASYNergyState(this.getFromSession(event.state.ASYNergy))\n\t\t\t\t: new ASYNergyState(event.state.ASYNergy);\n\n        state.replayResponses(callback);\n    },\n\n    currentState() {\n        if (! history.state) return new ASYNergyState;\n        if (! history.state.ASYNergy) return new ASYNergyState;\n\n        let state = typeof history.state.ASYNergy === 'string'\n            ? new ASYNergyState(this.getFromSession(history.state.ASYNergy))\n\t\t\t\t: new ASYNergyState(history.state.ASYNergy);\n\n        return state;\n    },\n\n    missingState(event) {\n\t\t\treturn ! (event.state && event.state.ASYNergy);\n    },\n\n    clearState() {\n        // This is to prevent exponentially increasing the size of our state on page refresh.\n        if (window.history.state) window.history.state.ASYNergy = (new ASYNergyState).toStateArray();\n    },\n\n    storeInSession(value) {\n\t\t\tlet key = 'asynergy:'+(new Date).getTime();\n\n\t\t\tlet stringifiedValue = JSON.stringify(value);\n\n\t\t\tthis.tryToStoreInSession(key, stringifiedValue);\n\n\t\t\treturn key;\n    },\n\n    tryToStoreInSession(key, value) {\n        // sessionStorage has a max storage limit (usally 5MB).\n        // If we meet that limit, we'll start removing entries\n        // (oldest first), until there's enough space to store\n        // the new one.\n        try {\n\t\t\t\t\tsessionStorage.setItem(key, value);\n        } catch (error) {\n            // 22 is Chrome, 1-14 is other browsers.\n            if (! [22, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14].includes(error.code)) return;\n\n            let oldestTimestamp = Object.keys(sessionStorage)\n                .map(key => Number(key.replace('asynergy:', '')))\n                .sort()\n\t\t\t\t\t\t.shift();\n\n            if (! oldestTimestamp) return;\n\n            sessionStorage.removeItem('asynergy:'+oldestTimestamp);\n\n            this.tryToStoreInSession(key, value);\n        }\n    },\n\n    getFromSession(key) {\n\t\t\tlet item = sessionStorage.getItem(key);\n\n        if (! item) return;\n\n        return JSON.parse(item);\n    },\n}\n\n\nclass ASYNergyState\n{\n    constructor(stateArray = []) { this.items = stateArray };\n\n    toStateArray() { return this.items };\n\n\n    pushItemInProperOrder(signature, response, agent) {\n        let targetItem = { signature, response };\n        \n        // REMOVE CIRCULAR REFERENCE TO AGENT IN agent.messageInTransit\n        // delete agent.messageInTransit;\n\n        // First, we'll check if this signature already has an entry, if so, replace it.\n        let existingIndex = this.items.findIndex(item => item.signature === signature);\n\n        if (existingIndex !== -1) return this.items[existingIndex] = targetItem;\n          \n          return this.items.unshift(targetItem);\n    }\n\n\n    storeResponse(response, agent) {\n      let signature = agent.agentID;\n\n      this.pushItemInProperOrder(signature, response, agent);\n    }\n\n\n\t\treplayResponses(callback) {\n\t\t\tlet state = ASYNergyStateManager.currentState();\n\t\t\tlet signature = state.items[0].signature;\n\t\t\tlet response = state.items[0].response;\n\t\t\tlet agent = this.findAgentBySignature(signature);\n\n\t\t\tif (! agent) return;\n          \n\t\t\tcallback(response, agent);\n\t\t}\n\n\n    findAgentBySignature(signature) {\n      let agent = store.getAgentsByID(signature);\n\n      // If we found the agent in the proper place, return it,\n      // otherwise return the first one.\n      return agent[0] || store.agents[0] || console.warn(`ASYNergy: couldn't find agent with ID: ${signature}`);\n    }\n\n}\n","/*!\n* ASYNergy\n*\n* revIgniter JavaScript application *\n* inspired by and adopted from Livewire *\n* a framework for making network requests *\n* and changing things on the page *\n* Version 0.3.0 *\n*\n* Author: Ralf Bitter, rabit@revigniter.com\n*\n*/\n\n\nimport { walkDOM } from './util/walkDOM';\nimport nodeInitializer from './init_tasks';\nimport store from './Store';\nimport Polling from './agent/Polling';\nimport DisableForms from './agent/DisableForms';\nimport LoadingStates from './agent/LoadingStates';\nimport SyncBrowserHistory from './agent/SyncBrowserHistory';\n\nclass ASYNergy {\n    constructor() {\n      this.appVersion = '0.3.0';\n      this.agents = store;\n      this.URL = '';\n    }\n\n    get version() {\n        return this.appVersion;\n    }\n  \n  set theURL(url) {\n    this.URL = url;\n  }\n\n  get theURL() {\n    return this.URL;\n  }\n\n    hook(name, callback) {\n      this.agents.registerHook(name, callback);\n    }\n\n    emit(event, ...params) {\n      this.agents.emit(event, ...params);\n    }\n\n    on(event, callback) {\n      this.agents.on(event, callback);\n    }\n\n    stop() {\n        this.agents.tearDownAgents();\n    }\n\n    reregisterEventListeners() {\n      const URL = this.URL !== '' ? this.URL : window.location.href;\n      const reregisterEvL = true;\n      const callBackFn = (el) => {\n          nodeInitializer.initialize(el, URL, reregisterEvL);\n      };\n      const bodyEl = document.body;\n      walkDOM(bodyEl, callBackFn);\n    }\n\n    start() {\n        // TODO check forms and handlerURL in init_tasks.js\n      const URL = this.URL !== '' ? this.URL : window.location.href;\n\n        const callBackFn = (el) => {\n            nodeInitializer.initialize(el, URL);\n        };\n\n        const bodyEl = document.body;\n\n        document.addEventListener(\n            'visibilitychange',\n            () => {\n              store.asynergyIsInBackground = document.hidden;\n            },\n            false\n        );\n\n        window.addEventListener('offline', () => {\n            store.asynergyIsOffline = true;\n        });\n\n        window.addEventListener('online', () => {\n            store.asynergyIsOffline = false;\n        });\n\n        walkDOM(bodyEl, callBackFn);\n    }\n}\n\nif (!window.ASYNergy) {\n    window.ASYNergy = ASYNergy;\n}\n\nSyncBrowserHistory();\nLoadingStates();\nDisableForms();\nPolling();\n\n\nexport default ASYNergy;\n","import store from '../Store';\nimport { asynDirectives } from '../util/asynDirectives';\n\nexport default function () {\n    store.registerHook('agent.initialized', agent => {\n      agent.targetedLoadingElsByAction = {};\n      agent.genericLoadingEls = [];\n      agent.currentlyActiveLoadingEls = [];\n      agent.currentlyActiveUploadLoadingEls = [];\n    });\n\n    store.registerHook('element.initialized', (el, agent) => {\n      let directives = asynDirectives(el);\n\n        if (directives.missing('loading')) return;\n\n        const loadingDirectives = directives.directives.filter(\n            i => i.type === 'loading'\n        );\n    });\n\n\n    store.registerHook('message.sent', (agent, message) => {\n        const actions = message.updateQueue\n            .filter(action => {\n              return action.type === 'callHandler';\n            })\n            .map(action => action.payload.modelAttrVal);\n\n        const actionsWithParams = message.updateQueue\n            .filter(action => {\n              return action.type === 'callHandler';\n            })\n            .map(action =>\n                generateSignatureFromHandlerAndParams(\n                  action.payload.modelAttrVal,\n                    action.payload.params\n                )\n            );\n\n      const models = message.updateQueue\n        .filter(action => {\n          return action.type === 'syncInput';\n        })\n        .map(action => {\n          let name = action.payload.modelAttrVal;\n          if (!name.includes('.')) {\n            return name;\n          }\n\n          let modelActions = [];\n\n          modelActions.push(\n            name.split('.').reduce((fullAction, part) => {\n              modelActions.push(fullAction);\n\n              return fullAction + '.' + part;\n            })\n          );\n\n          return modelActions;\n        })\n        .flat();\n    });\n}\n\nexport function setUploadLoading(agent, modelName) {\n    const actionTargetedEls =\n  agent.targetedLoadingElsByAction[modelName] || [];\n\n  const allEls = removeDuplicates(agent.genericLoadingEls.concat(actionTargetedEls));\n\n  startLoading(allEls);\n\n  agent.currentlyActiveUploadLoadingEls = allEls;\n}\n\n\nexport function unsetUploadLoading(agent) {\n  endLoading(agent.currentlyActiveUploadLoadingEls);\n\n  agent.currentlyActiveUploadLoadingEls = [];\n}\n\n\nfunction startLoading(els) {\n    els.forEach(({ el, directive }) => {\n        if (directive.modifiers.includes('class')) {\n          let classes = directive.value.split(' ').filter(Boolean);\n\n            doAndSetCallbackOnElToUndo(\n                el,\n                directive,\n                () => el.classList.add(...classes),\n                () => el.classList.remove(...classes)\n            );\n        } else if (directive.modifiers.includes('attr')) {\n            doAndSetCallbackOnElToUndo(\n                el,\n                directive,\n                () => el.setAttribute(directive.value, true),\n                () => el.removeAttribute(directive.value)\n            );\n        } else {\n            let cache = window\n                .getComputedStyle(el, null)\n          .getPropertyValue('display');\n\n            doAndSetCallbackOnElToUndo(\n                el,\n                directive,\n                () => {\n                  el.style.display = directive.modifiers.includes('remove')\n                    ? cache\n                    : getDisplayProperty(directive);\n                },\n                () => {\n                  el.style.display = 'none';\n                }\n            );\n        }\n    });\n}\n\n\nfunction getDisplayProperty(directive) {\n    return (['inline', 'block', 'table', 'flex', 'grid', 'inline-flex']\n  .filter(i => directive.modifiers.includes(i))[0] || 'inline-block');\n}\n\n\nfunction doAndSetCallbackOnElToUndo(el, directive, doCallback, undoCallback) {\n  if (directive.modifiers.includes('remove'))\n    [doCallback, undoCallback] = [undoCallback, doCallback];\n\n    if (directive.modifiers.includes('delay')) {\n      let duration = 200;\n\n        let delayModifiers = {\n            'shortest': 50,\n            'shorter': 100,\n            'short': 150,\n            'long': 300,\n            'longer': 500,\n            'longest': 1000,\n        };\n\n        Object.keys(delayModifiers).some(key => {\n            if(directive.modifiers.includes(key)) {\n              duration = delayModifiers[key];\n              return true;\n            }\n        });\n\n      let timeout = setTimeout(() => {\n        doCallback();\n        el.__asynergy_on_finish_loading.push(() => undoCallback());\n      }, duration);\n\n      el.__asynergy_on_finish_loading.push(() => clearTimeout(timeout));\n    } else {\n      doCallback();\n      el.__asynergy_on_finish_loading.push(() => undoCallback());\n    }\n}\n\n\nfunction endLoading(els) {\n  els.forEach(({ el }) => {\n    while (el.__asynergy_on_finish_loading.length > 0) {\n      el.__asynergy_on_finish_loading.shift()();\n    }\n  });\n}\n\n\nfunction generateSignatureFromHandlerAndParams(handler, params) {\n  return handler + btoa(encodeURIComponent(handler.toString()));\n}\n\n\nfunction removeDuplicates(arr) {\n  return Array.from(new Set(arr));\n}\n","import HandlerAction from '../action/handler';\nimport { asynDirectives } from '../util/asynDirectives';\nimport store from '../Store';\n\nexport default function () {\n    store.registerHook('element.initialized', (el, agent) => {\n        let directive = asynDirectives(el).get('poll');\n\n        if (directive === undefined) {\n            return;\n        }\n\n        let intervalId = fireActionOnInterval(el, agent);\n\n        agent.addListenerForTeardown(() => {\n          clearInterval(intervalId);\n        });\n\n        el.__asynergy_polling_interval = intervalId;\n    });\n}\n\nfunction fireActionOnInterval(node, agent) {\n    let interval = asynDirectives(node).get('poll').durationOr(2000);\n\n    return setInterval(() => {\n        if (node.isConnected === false) {\n            return;\n        }\n\n        const directive = asynDirectives(node).get('poll');\n\n        if (directive === undefined) {\n            return;\n        }\n\n        const handler = directive.handler || 'refresh';\n\n        // Don't poll when the tab is in the background.\n        // (unless the \"asyn:poll.keep-alive\" modifier is attached)\n        if (store.asynergyIsInBackground && !directive.modifiers.includes('keep-alive')) {\n            // This \"Math.random\" business effectivlly prevents 95% of requests\n            // from executing. We still want \"some\" requests to get through.\n            if (Math.random() < .95) {\n                return;\n            }\n        }\n\n        // Only poll visible elements. Visible elements are elements that\n        // are visible in the current viewport.\n        if (directive.modifiers.includes('visible') && !inViewport(directive.el)) {\n            return;\n        }\n\n        // Don't poll if asynergy is offline as well.\n        if (store.asynergyIsOffline) {\n            return;\n        }\n        agent.addAction(new HandlerAction(handler, directive.params, directive.modelValue, directive.emitEvent, node));\n    }, interval);\n}\n\nfunction inViewport(el) {\n    var bounding = el.getBoundingClientRect();\n\n    return (\n        bounding.top < (window.innerHeight || document.documentElement.clientHeight) &&\n        bounding.left < (window.innerWidth || document.documentElement.clientWidth) &&\n        bounding.bottom > 0 &&\n        bounding.right > 0\n    );\n}\n"],"mappings":"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","ignoreList":[]}